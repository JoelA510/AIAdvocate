-- ================================================================
-- AI ADVOCATE: V1.6.1 CONSOLIDATED SCHEMA & POLICIES (IDEMPOTENT)
-- Vector search, ranked FTS, translations cache, RLS, realtime guard
-- ================================================================

-- ---------- EXTENSIONS ----------
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS supabase_vault;

-- ---------- CORE TABLES ----------
CREATE TABLE IF NOT EXISTS public.bills (
  id BIGINT PRIMARY KEY,
  bill_number TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  change_hash TEXT,
  is_curated BOOLEAN DEFAULT FALSE,
  original_text TEXT,
  original_text_formatted TEXT,
  summary_ok BOOLEAN,
  summary_len_simple INTEGER,
  summary_hash TEXT,
  summary_lease_until TIMESTAMPTZ,
  summary_lease_owner TEXT,
  embedding vector(1536) -- semantic search
);
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_text TEXT;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_date DATE;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS progress JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS calendar JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS history JSONB;

CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.legislators (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  party TEXT,
  district TEXT,
  chamber TEXT,
  photo_url TEXT,
  email TEXT,
  is_lnf_ally BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  vote TEXT NOT NULL, -- yes/no/abstain/absent
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (bill_id, legislator_id)
);

-- User interaction
CREATE TABLE IF NOT EXISTS public.reactions (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reaction_type TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.bookmarks (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.app_admins (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Translations cache
CREATE TABLE IF NOT EXISTS public.bill_translations (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, -- ISO 639-1 (e.g., 'es')
  title TEXT,
  description TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  original_text TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, language_code)
);

CREATE TABLE IF NOT EXISTS public.location_lookup_cache (
  lookup_key TEXT PRIMARY KEY,
  raw_query TEXT NOT NULL,
  query_type TEXT NOT NULL CHECK (query_type IN ('zip', 'city')),
  lat DOUBLE PRECISION NOT NULL,
  lon DOUBLE PRECISION NOT NULL,
  representatives JSONB NOT NULL,
  hit_count INTEGER NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_hit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '7 days')
);

-- Notifications & analytics
CREATE TABLE IF NOT EXISTS public.user_push_tokens (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  expo_token TEXT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('saved', 'upvoted')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, bill_id)
);

CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts TIMESTAMPTZ DEFAULT NOW(),
  user_id UUID,
  type TEXT NOT NULL,
  bill_id BIGINT
);

-- Infra
CREATE TABLE IF NOT EXISTS public.cron_job_errors (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  job_name TEXT NOT NULL,
  error_message TEXT NOT NULL,
  occurred_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION public.invoke_edge_function(endpoint TEXT, job_name TEXT DEFAULT 'daily-bill-sync')
RETURNS VOID AS $$
DECLARE
  request_id BIGINT;
BEGIN
  BEGIN
    SELECT net.http_post(
      url := 'https://klpwiiszmzzfvlbfsjrd.supabase.co/functions/v1/' || endpoint,
      headers := '{"Content-Type": "application/json"}'
    )
    INTO request_id;
  EXCEPTION
    WHEN OTHERS THEN
      INSERT INTO public.cron_job_errors (job_name, error_message)
      VALUES (
        job_name,
        'Invoke Error: Edge Function ' || endpoint || ' failed with ' || SQLERRM
      );
      RETURN;
  END;

  IF request_id IS NULL THEN
    INSERT INTO public.cron_job_errors (job_name, error_message)
    VALUES (
      job_name,
      'Invoke Error: Edge Function ' || endpoint || ' returned null request id'
    );
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.invoke_sync_updated_bills() RETURNS VOID AS $$
BEGIN
  PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.upsert_bill_and_translation(bill JSONB, tr JSONB)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF bill IS NULL THEN
    RAISE EXCEPTION 'bill payload is required';
  END IF;

  INSERT INTO public.bills (
    id,
    bill_number,
    title,
    description,
    status,
    status_text,
    status_date,
    state_link,
    change_hash,
    original_text,
    original_text_formatted,
    summary_simple,
    summary_medium,
    summary_complex,
    summary_ok,
    summary_len_simple,
    summary_hash,
    progress,
    calendar,
    history,
    embedding
  )
  SELECT
    (bill->>'id')::BIGINT,
    bill->>'bill_number',
    bill->>'title',
    bill->>'description',
    NULLIF(bill->>'status', ''),
    bill->>'status_text',
    (bill->>'status_date')::DATE,
    bill->>'state_link',
    bill->>'change_hash',
    bill->>'original_text',
    bill->>'original_text_formatted',
    bill->>'summary_simple',
    bill->>'summary_medium',
    bill->>'summary_complex',
    (bill->>'summary_ok')::BOOLEAN,
    (bill->>'summary_len_simple')::INTEGER,
    bill->>'summary_hash',
    bill->'progress',
    bill->'calendar',
    bill->'history',
    CASE WHEN bill ? 'embedding' THEN (bill->>'embedding')::vector ELSE NULL END
  ON CONFLICT (id) DO UPDATE SET
    bill_number = EXCLUDED.bill_number,
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    status = EXCLUDED.status,
    status_text = EXCLUDED.status_text,
    status_date = EXCLUDED.status_date,
    state_link = EXCLUDED.state_link,
    change_hash = EXCLUDED.change_hash,
    original_text = EXCLUDED.original_text,
    original_text_formatted = EXCLUDED.original_text_formatted,
    summary_simple = EXCLUDED.summary_simple,
    summary_medium = EXCLUDED.summary_medium,
    summary_complex = EXCLUDED.summary_complex,
    summary_ok = EXCLUDED.summary_ok,
    summary_len_simple = EXCLUDED.summary_len_simple,
    summary_hash = EXCLUDED.summary_hash,
    progress = EXCLUDED.progress,
    calendar = EXCLUDED.calendar,
    history = EXCLUDED.history,
    embedding = CASE
      WHEN EXCLUDED.summary_hash IS DISTINCT FROM public.bills.summary_hash THEN EXCLUDED.embedding
      ELSE public.bills.embedding
    END;

  IF tr IS NOT NULL THEN
    INSERT INTO public.bill_translations (
      bill_id,
      language_code,
      summary_simple,
      summary_medium,
      summary_complex,
      updated_at
    )
    VALUES (
      (tr->>'bill_id')::BIGINT,
      tr->>'language_code',
      tr->>'summary_simple',
      tr->>'summary_medium',
      tr->>'summary_complex',
      COALESCE((tr->>'updated_at')::TIMESTAMPTZ, NOW())
    )
    ON CONFLICT (bill_id, language_code) DO UPDATE SET
      summary_simple = EXCLUDED.summary_simple,
      summary_medium = EXCLUDED.summary_medium,
      summary_complex = EXCLUDED.summary_complex,
      updated_at = EXCLUDED.updated_at;
  END IF;
END;
$$;

REVOKE ALL ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) TO service_role;

CREATE OR REPLACE FUNCTION public.lease_next_bill(p_owner text, p_ttl_seconds int DEFAULT 900)
RETURNS BIGINT
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  WITH cte AS (
    SELECT id FROM public.bills
    WHERE (summary_ok IS DISTINCT FROM TRUE)
      AND (summary_lease_until IS NULL OR summary_lease_until < now())
    ORDER BY id
    FOR UPDATE SKIP LOCKED
    LIMIT 1
  )
  UPDATE public.bills b
     SET summary_lease_until = now() + make_interval(secs => p_ttl_seconds),
         summary_lease_owner = p_owner
  FROM cte
  WHERE b.id = cte.id
  RETURNING b.id;
$$;

REVOKE ALL ON FUNCTION public.lease_next_bill(text, int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.lease_next_bill(text, int) TO service_role;

CREATE OR REPLACE FUNCTION public.release_bill_lease(p_id bigint, p_owner text, p_ok boolean)
RETURNS void
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE public.bills
     SET summary_ok = p_ok,
         summary_lease_until = NULL,
         summary_lease_owner = NULL
   WHERE id = p_id
     AND summary_lease_owner = p_owner;
$$;

REVOKE ALL ON FUNCTION public.release_bill_lease(bigint, text, boolean) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.release_bill_lease(bigint, text, boolean) TO service_role;

CREATE OR REPLACE VIEW public.v_bill_summary_leases AS
SELECT id, summary_ok, summary_lease_owner, summary_lease_until
FROM public.bills
WHERE summary_ok IS DISTINCT FROM TRUE
   OR summary_lease_until IS NOT NULL;

CREATE OR REPLACE FUNCTION public.invoke_full_legislative_refresh() RETURNS VOID AS $$
DECLARE
  i INT;
BEGIN
  PERFORM public.invoke_edge_function('bulk-import-dataset', 'daily-bill-sync');
  FOR i IN 1..5 LOOP
    PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
  END LOOP;
  PERFORM public.invoke_edge_function('sync-legislators-and-votes', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- App config (public values read by clients)
CREATE TABLE IF NOT EXISTS public.app_config (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ---------- INDEXES ----------
CREATE INDEX IF NOT EXISTS idx_bills_change_hash ON public.bills(change_hash);
CREATE INDEX IF NOT EXISTS idx_bills_bill_number ON public.bills(bill_number);
CREATE INDEX IF NOT EXISTS idx_bills_embed ON public.bills
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS bills_summary_ok_idx
  ON public.bills ((summary_ok IS DISTINCT FROM TRUE));
CREATE INDEX IF NOT EXISTS idx_cron_job_errors_occurred_at ON public.cron_job_errors(occurred_at);
CREATE INDEX IF NOT EXISTS idx_location_lookup_cache_expires_at ON public.location_lookup_cache(expires_at);

-- ---------- FULL-TEXT SEARCH (ranked) ----------
ALTER TABLE public.bills
  ADD COLUMN IF NOT EXISTS search tsvector
  GENERATED ALWAYS AS (
    setweight(to_tsvector('english', coalesce(bill_number, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(description, '')), 'B') ||
    setweight(to_tsvector('english', coalesce(summary_simple, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_medium, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_complex, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(original_text, '')), 'D')
  ) STORED;

CREATE INDEX IF NOT EXISTS bills_search_gin ON public.bills USING GIN (search);

-- ---------- RLS ----------
ALTER TABLE public.bills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.legislators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bill_translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.location_lookup_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_push_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cron_job_errors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.app_admins FROM anon;
REVOKE ALL ON TABLE public.app_admins FROM authenticated;

-- Public readable tables
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bills' AND policyname='Public can view bills') THEN
    CREATE POLICY "Public can view bills" ON public.bills FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='legislators' AND policyname='Public can view legislators') THEN
    CREATE POLICY "Public can view legislators" ON public.legislators FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='votes' AND policyname='Public can view votes') THEN
    CREATE POLICY "Public can view votes" ON public.votes FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Public can view translations') THEN
    CREATE POLICY "Public can view translations" ON public.bill_translations FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='location_lookup_cache' AND policyname='Public can read location cache') THEN
    CREATE POLICY "Public can read location cache" ON public.location_lookup_cache FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='app_admins' AND policyname='Admins can read own record') THEN
    CREATE POLICY "Admins can read own record" ON public.app_admins
      FOR SELECT TO authenticated USING (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='app_config' AND policyname='Allow authenticated users to read config') THEN
    CREATE POLICY "Allow authenticated users to read config" ON public.app_config FOR SELECT TO authenticated USING (true);
  END IF;
END $$;

GRANT SELECT ON TABLE public.app_admins TO authenticated;

-- User-owned tables (USING + WITH CHECK)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='reactions' AND policyname='Users can manage their own reactions') THEN
    CREATE POLICY "Users can manage their own reactions" ON public.reactions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bookmarks' AND policyname='Users can manage their own bookmarks') THEN
    CREATE POLICY "Users can manage their own bookmarks" ON public.bookmarks
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='subscriptions' AND policyname='Users can manage their own subscriptions') THEN
    CREATE POLICY "Users can manage their own subscriptions" ON public.subscriptions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Service role write policies (WITH CHECK for RLS writes)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Service role can manage translations') THEN
    DROP POLICY "Service role can manage translations" ON public.bill_translations;
  END IF;
  CREATE POLICY "Service role can manage translations" ON public.bill_translations
    FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='events' AND policyname='Allow service role to insert events') THEN
    CREATE POLICY "Allow service role to insert events" ON public.events
      FOR INSERT WITH CHECK (auth.role() = 'service_role');
  END IF;
END $$;

-- ---------- RPCs ----------
-- Toggle Bookmark + Subscription
CREATE OR REPLACE FUNCTION public.toggle_bookmark_and_subscription(p_bill_id BIGINT, p_user_id UUID)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE bookmark_exists BOOLEAN;
BEGIN
  SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id)
  INTO bookmark_exists;

  IF bookmark_exists THEN
    DELETE FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id;
    DELETE FROM public.subscriptions WHERE user_id = p_user_id AND bill_id = p_bill_id;
  ELSE
    INSERT INTO public.bookmarks (user_id, bill_id) VALUES (p_user_id, p_bill_id);
    INSERT INTO public.subscriptions (user_id, bill_id, type)
      VALUES (p_user_id, p_bill_id, 'saved')
      ON CONFLICT (user_id, bill_id) DO NOTHING;
  END IF;
END;
$$;

COMMENT ON FUNCTION public.toggle_bookmark_and_subscription(BIGINT, UUID)
IS 'Atomically toggles a user bookmark and matching subscription.';

-- Related bills via embeddings
CREATE OR REPLACE FUNCTION public.get_related_bills(p_bill_id BIGINT)
RETURNS TABLE (id BIGINT, bill_number TEXT, title TEXT, similarity FLOAT)
LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  WITH source_bill AS (SELECT embedding FROM public.bills WHERE bills.id = p_bill_id)
  SELECT
    b.id, b.bill_number, b.title,
    (1 - (b.embedding <=> (SELECT embedding FROM source_bill)))::FLOAT AS similarity
  FROM public.bills b, source_bill
  WHERE b.id <> p_bill_id AND b.embedding IS NOT NULL
  ORDER BY b.embedding <=> (SELECT embedding FROM source_bill)
  LIMIT 5;
END;
$$;

COMMENT ON FUNCTION public.get_related_bills(BIGINT)
IS 'Returns top 5 semantically similar bills using vector embeddings.';

CREATE OR REPLACE FUNCTION public.search_bills(p_query TEXT)
RETURNS TABLE (
  id BIGINT,
  bill_number TEXT,
  title TEXT,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN,
  created_at TIMESTAMPTZ,
  change_hash TEXT,
  is_curated BOOLEAN,
  original_text TEXT,
  embedding vector(1536),
  status_text TEXT,
  status_date DATE,
  progress JSONB,
  calendar JSONB,
  history JSONB,
  rank DOUBLE PRECISION
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
  trimmed TEXT := trim(p_query);
  condensed TEXT := regexp_replace(trimmed, '\s+', '', 'g');
  tsq TSQUERY;
  result_rows INTEGER;
BEGIN
  IF trimmed IS NULL OR trimmed = '' THEN
    RETURN;
  END IF;

  IF length(condensed) < 3 THEN
    RETURN QUERY
    SELECT
      b.id,
      b.bill_number,
      b.title,
      b.description,
      b.status,
      b.state_link,
      b.summary_simple,
      b.summary_medium,
      b.summary_complex,
      b.panel_review,
      b.is_verified,
      b.created_at,
      b.change_hash,
      b.is_curated,
      b.original_text,
      b.embedding,
      b.status_text,
      b.status_date,
      b.progress,
      b.calendar,
      b.history,
      0::DOUBLE PRECISION AS rank
    FROM public.bills b
    WHERE
      b.bill_number ILIKE concat(condensed, '%')
      OR b.bill_number ILIKE concat('%', condensed, '%')
      OR b.title ILIKE concat('%', trimmed, '%')
    ORDER BY
      b.is_curated DESC,
      COALESCE(b.status_date, b.created_at) DESC,
      b.created_at DESC,
      b.id DESC;
    RETURN;
  END IF;

  tsq := websearch_to_tsquery('english', trimmed);

  IF tsq IS NOT NULL AND tsq::text <> '' THEN
    RETURN QUERY
    WITH docs AS (
      SELECT
        b.*,
        setweight(to_tsvector('english', coalesce(b.bill_number, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(b.title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(b.description, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(b.summary_simple, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(b.summary_medium, '')), 'C') ||
        setweight(to_tsvector('english', coalesce(b.summary_complex, '')), 'C') ||
        setweight(to_tsvector('english', coalesce(b.original_text, '')), 'D') AS document
      FROM public.bills b
    )
    SELECT
      d.id,
      d.bill_number,
      d.title,
      d.description,
      d.status,
      d.state_link,
      d.summary_simple,
      d.summary_medium,
      d.summary_complex,
      d.panel_review,
      d.is_verified,
      d.created_at,
      d.change_hash,
      d.is_curated,
      d.original_text,
      d.embedding,
      d.status_text,
      d.status_date,
      d.progress,
      d.calendar,
      d.history,
      ts_rank_cd(d.document, tsq)::DOUBLE PRECISION AS rank
    FROM docs d
    WHERE d.document @@ tsq
    ORDER BY rank DESC, d.is_curated DESC, d.created_at DESC;

    GET DIAGNOSTICS result_rows = ROW_COUNT;
    IF result_rows > 0 THEN
      RETURN;
    END IF;
  END IF;

  RETURN QUERY
  SELECT
    b.id,
    b.bill_number,
    b.title,
    b.description,
    b.status,
    b.state_link,
    b.summary_simple,
    b.summary_medium,
    b.summary_complex,
    b.panel_review,
    b.is_verified,
    b.created_at,
    b.change_hash,
    b.is_curated,
    b.original_text,
    b.embedding,
    b.status_text,
    b.status_date,
    b.progress,
    b.calendar,
    b.history,
    0::DOUBLE PRECISION AS rank
  FROM public.bills b
  WHERE
    b.bill_number ILIKE concat('%', trimmed, '%')
    OR b.title ILIKE concat('%', trimmed, '%')
    OR b.description ILIKE concat('%', trimmed, '%')
  ORDER BY
    b.is_curated DESC,
    COALESCE(b.status_date, b.created_at) DESC,
    b.created_at DESC,
    b.id DESC;
END;
$$;

COMMENT ON FUNCTION public.search_bills(TEXT)
IS 'Ranked websearch over bills.search tsvector with graceful fallback for short or sparse queries.';

-- Simple profile bootstrap on new auth user
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id) VALUES (NEW.id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Cron helpers
CREATE OR REPLACE FUNCTION public.cleanup_old_cron_job_errors() RETURNS VOID AS $$
BEGIN
  DELETE FROM public.cron_job_errors WHERE occurred_at < NOW() - INTERVAL '30 days';
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.cleanup_expired_location_cache() RETURNS VOID AS $$
BEGIN
  DELETE FROM public.location_lookup_cache WHERE expires_at <= NOW();
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync') THEN
    PERFORM cron.unschedule('daily-bill-sync');
  END IF;
END;
$$;

SELECT cron.schedule('daily-bill-sync', '0 10 * * *', 'SELECT public.invoke_full_legislative_refresh()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync');

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors') THEN
    PERFORM cron.unschedule('cleanup-cron-job-errors');
  END IF;
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-location-cache') THEN
    PERFORM cron.unschedule('cleanup-location-cache');
  END IF;
END;
$$;

SELECT cron.schedule('cleanup-cron-job-errors', '0 0 * * 0', 'SELECT public.cleanup_old_cron_job_errors()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors');

SELECT cron.schedule('cleanup-location-cache', '0 3 * * *', 'SELECT public.cleanup_expired_location_cache()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-location-cache');

-- ---------- REALTIME (guarded) ----------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime'
      AND schemaname = 'public'
      AND tablename = 'bookmarks'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.bookmarks';
  END IF;
END $$;

-- ---------- COMMENTS ----------
COMMENT ON TABLE public.bills IS 'Core legislative bill info + AI-generated content + embedding + FTS vector.';
COMMENT ON COLUMN public.bills.embedding IS 'Vector embeddings for semantic search.';
COMMENT ON TABLE public.bill_translations IS 'Caches AI-generated translations per bill per language.';
COMMENT ON TABLE public.user_push_tokens IS 'Expo push tokens per user.';
COMMENT ON TABLE public.subscriptions IS 'Bill subscriptions (saved/upvoted) for notifications.';
COMMENT ON TABLE public.events IS 'Anonymous analytics events.';
COMMENT ON TABLE public.app_admins IS 'Whitelist of application admins by user_id (auth.users).';
COMMENT ON TABLE public.location_lookup_cache IS 'Caches non-specific location lookups (ZIP or city) to reduce external API usage.';
COMMENT ON COLUMN public.location_lookup_cache.lookup_key IS 'Normalized cache key in the form "<type>:<value>" (type is zip or city).';
COMMENT ON COLUMN public.location_lookup_cache.representatives IS 'Cached OpenStates representatives array for the location.';
