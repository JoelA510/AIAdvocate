-- ================================================================
-- AI ADVOCATE: V1.6.1 CONSOLIDATED SCHEMA & POLICIES (IDEMPOTENT)
-- Vector search, ranked FTS, translations cache, RLS, realtime guard
-- ================================================================

-- ---------- EXTENSIONS ----------
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS supabase_vault;

-- ---------- CORE TABLES ----------
CREATE TABLE IF NOT EXISTS public.bills (
  id BIGINT PRIMARY KEY,
  bill_number TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  change_hash TEXT,
  is_curated BOOLEAN DEFAULT FALSE,
  original_text TEXT,
  embedding vector(1536) -- semantic search
);
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_text TEXT;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_date DATE;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS progress JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS calendar JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS history JSONB;

CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.legislators (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  party TEXT,
  district TEXT,
  chamber TEXT,
  photo_url TEXT,
  email TEXT,
  is_lnf_ally BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  vote TEXT NOT NULL, -- yes/no/abstain/absent
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (bill_id, legislator_id)
);

-- User interaction
CREATE TABLE IF NOT EXISTS public.reactions (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reaction_type TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.bookmarks (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

-- Translations cache
CREATE TABLE IF NOT EXISTS public.bill_translations (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, -- ISO 639-1 (e.g., 'es')
  title TEXT,
  description TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  original_text TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, language_code)
);

-- Notifications & analytics
CREATE TABLE IF NOT EXISTS public.user_push_tokens (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  expo_token TEXT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('saved', 'upvoted')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, bill_id)
);

CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts TIMESTAMPTZ DEFAULT NOW(),
  user_id UUID,
  type TEXT NOT NULL,
  bill_id BIGINT
);

-- Infra
CREATE TABLE IF NOT EXISTS public.cron_job_errors (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  job_name TEXT NOT NULL,
  error_message TEXT NOT NULL,
  occurred_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION public.invoke_edge_function(endpoint TEXT, job_name TEXT DEFAULT 'daily-bill-sync')
RETURNS VOID AS $$
DECLARE
  status_code INT;
  anon_key TEXT;
BEGIN
  anon_key := vault.get_secret('supabase_anon_key');
  SELECT status INTO status_code
  FROM net.http_post(
    url := 'https://klpwiiszmzzfvlbfsjrd.supabase.co/functions/v1/' || endpoint,
    headers := '{"Content-Type": "application/json", "apikey": "' || anon_key || '"}'
  );
  IF status_code != 200 THEN
    INSERT INTO public.cron_job_errors (job_name, error_message)
    VALUES (job_name, 'Invoke Error: Edge Function ' || endpoint || ' returned status ' || status_code);
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.invoke_sync_updated_bills() RETURNS VOID AS $$
BEGIN
  PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.invoke_full_legislative_refresh() RETURNS VOID AS $$
DECLARE
  i INT;
BEGIN
  PERFORM public.invoke_edge_function('bulk-import-dataset', 'daily-bill-sync');
  FOR i IN 1..5 LOOP
    PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
  END LOOP;
  PERFORM public.invoke_edge_function('sync-legislators-and-votes', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- App config (public values read by clients)
CREATE TABLE IF NOT EXISTS public.app_config (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ---------- INDEXES ----------
CREATE INDEX IF NOT EXISTS idx_bills_change_hash ON public.bills(change_hash);
CREATE INDEX IF NOT EXISTS idx_bills_bill_number ON public.bills(bill_number);
CREATE INDEX IF NOT EXISTS idx_bills_embed ON public.bills
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS idx_cron_job_errors_occurred_at ON public.cron_job_errors(occurred_at);

-- ---------- FULL-TEXT SEARCH (ranked) ----------
ALTER TABLE public.bills
  ADD COLUMN IF NOT EXISTS search tsvector
  GENERATED ALWAYS AS (
    setweight(to_tsvector('english', coalesce(bill_number, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(description, '')), 'B') ||
    setweight(to_tsvector('english', coalesce(summary_simple, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_medium, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_complex, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(original_text, '')), 'D')
  ) STORED;

CREATE INDEX IF NOT EXISTS bills_search_gin ON public.bills USING GIN (search);

-- ---------- RLS ----------
ALTER TABLE public.bills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.legislators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bill_translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_push_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cron_job_errors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;

-- Public readable tables
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bills' AND policyname='Public can view bills') THEN
    CREATE POLICY "Public can view bills" ON public.bills FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='legislators' AND policyname='Public can view legislators') THEN
    CREATE POLICY "Public can view legislators" ON public.legislators FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='votes' AND policyname='Public can view votes') THEN
    CREATE POLICY "Public can view votes" ON public.votes FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Public can view translations') THEN
    CREATE POLICY "Public can view translations" ON public.bill_translations FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='app_config' AND policyname='Allow authenticated users to read config') THEN
    CREATE POLICY "Allow authenticated users to read config" ON public.app_config FOR SELECT TO authenticated USING (true);
  END IF;
END $$;

-- User-owned tables (USING + WITH CHECK)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='reactions' AND policyname='Users can manage their own reactions') THEN
    CREATE POLICY "Users can manage their own reactions" ON public.reactions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bookmarks' AND policyname='Users can manage their own bookmarks') THEN
    CREATE POLICY "Users can manage their own bookmarks" ON public.bookmarks
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='subscriptions' AND policyname='Users can manage their own subscriptions') THEN
    CREATE POLICY "Users can manage their own subscriptions" ON public.subscriptions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Service role write policies (WITH CHECK for RLS writes)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Service role can manage translations') THEN
    DROP POLICY "Service role can manage translations" ON public.bill_translations;
  END IF;
  CREATE POLICY "Service role can manage translations" ON public.bill_translations
    FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='events' AND policyname='Allow service role to insert events') THEN
    CREATE POLICY "Allow service role to insert events" ON public.events
      FOR INSERT WITH CHECK (auth.role() = 'service_role');
  END IF;
END $$;

-- ---------- RPCs ----------
-- Toggle Bookmark + Subscription
CREATE OR REPLACE FUNCTION public.toggle_bookmark_and_subscription(p_bill_id BIGINT, p_user_id UUID)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE bookmark_exists BOOLEAN;
BEGIN
  SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id)
  INTO bookmark_exists;

  IF bookmark_exists THEN
    DELETE FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id;
    DELETE FROM public.subscriptions WHERE user_id = p_user_id AND bill_id = p_bill_id;
  ELSE
    INSERT INTO public.bookmarks (user_id, bill_id) VALUES (p_user_id, p_bill_id);
    INSERT INTO public.subscriptions (user_id, bill_id, type)
      VALUES (p_user_id, p_bill_id, 'saved')
      ON CONFLICT (user_id, bill_id) DO NOTHING;
  END IF;
END;
$$;

COMMENT ON FUNCTION public.toggle_bookmark_and_subscription(BIGINT, UUID)
IS 'Atomically toggles a user bookmark and matching subscription.';

-- Related bills via embeddings
CREATE OR REPLACE FUNCTION public.get_related_bills(p_bill_id BIGINT)
RETURNS TABLE (id BIGINT, bill_number TEXT, title TEXT, similarity FLOAT)
LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  WITH source_bill AS (SELECT embedding FROM public.bills WHERE bills.id = p_bill_id)
  SELECT
    b.id, b.bill_number, b.title,
    (1 - (b.embedding <=> (SELECT embedding FROM source_bill)))::FLOAT AS similarity
  FROM public.bills b, source_bill
  WHERE b.id <> p_bill_id AND b.embedding IS NOT NULL
  ORDER BY b.embedding <=> (SELECT embedding FROM source_bill)
  LIMIT 5;
END;
$$;

COMMENT ON FUNCTION public.get_related_bills(BIGINT)
IS 'Returns top 5 semantically similar bills using vector embeddings.';

-- Ranked full-text search over generated "search" column
CREATE OR REPLACE FUNCTION public.search_bills(p_query TEXT)
RETURNS TABLE (
  id BIGINT,
  bill_number TEXT,
  title TEXT,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN,
  created_at TIMESTAMPTZ,
  change_hash TEXT,
  is_curated BOOLEAN,
  original_text TEXT,
  embedding vector(1536),
  rank DOUBLE PRECISION
)
LANGUAGE sql STABLE AS $$
  SELECT
    b.*,
    ts_rank_cd(b.search, websearch_to_tsquery('english', p_query)) AS rank
  FROM public.bills b
  WHERE b.search @@ websearch_to_tsquery('english', p_query)
  ORDER BY rank DESC, created_at DESC;
$$;

COMMENT ON FUNCTION public.search_bills(TEXT)
IS 'Ranked websearch over bills.search tsvector. Returns bills + rank.';

-- Simple profile bootstrap on new auth user
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id) VALUES (NEW.id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Cron helpers
CREATE OR REPLACE FUNCTION public.cleanup_old_cron_job_errors() RETURNS VOID AS $$
BEGIN
  DELETE FROM public.cron_job_errors WHERE occurred_at < NOW() - INTERVAL '30 days';
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync') THEN
    PERFORM cron.unschedule('daily-bill-sync');
  END IF;
END;
$$;

SELECT cron.schedule('daily-bill-sync', '0 10 * * *', 'SELECT public.invoke_full_legislative_refresh()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync');

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors') THEN
    PERFORM cron.unschedule('cleanup-cron-job-errors');
  END IF;
END;
$$;

SELECT cron.schedule('cleanup-cron-job-errors', '0 0 * * 0', 'SELECT public.cleanup_old_cron_job_errors()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors');

-- ---------- REALTIME (guarded) ----------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime'
      AND schemaname = 'public'
      AND tablename = 'bookmarks'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.bookmarks';
  END IF;
END $$;

-- ---------- COMMENTS ----------
COMMENT ON TABLE public.bills IS 'Core legislative bill info + AI-generated content + embedding + FTS vector.';
COMMENT ON COLUMN public.bills.embedding IS 'Vector embeddings for semantic search.';
COMMENT ON TABLE public.bill_translations IS 'Caches AI-generated translations per bill per language.';
COMMENT ON TABLE public.user_push_tokens IS 'Expo push tokens per user.';
COMMENT ON TABLE public.subscriptions IS 'Bill subscriptions (saved/upvoted) for notifications.';
COMMENT ON TABLE public.events IS 'Anonymous analytics events.';
