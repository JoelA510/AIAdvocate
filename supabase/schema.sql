-- =================================================================
-- AI ADVOCATE: V1 STABLE SCHEMA (MERGED & COMPLETE - V2)
-- This script is idempotent and contains the complete schema for the
-- V1 stable build, including all tables, functions, and extensions for
-- all features implemented.
-- =================================================================

-- SECTION 1: EXTENSIONS
CREATE EXTENSION IF NOT EXISTS supabase_vault;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS vector; -- For semantic search

CREATE TYPE IF NOT EXISTS public.vote_choice AS ENUM (
  'yay',
  'nay',
  'abstain',
  'absent',
  'excused',
  'other'
);

-- SECTION 2: CORE TABLES
CREATE TABLE IF NOT EXISTS public.bills (
  id BIGINT PRIMARY KEY, bill_number TEXT NOT NULL, title TEXT NOT NULL, description TEXT,
  status TEXT, state_link TEXT, summary_simple TEXT, summary_medium TEXT, summary_complex TEXT,
  panel_review JSONB, is_verified BOOLEAN DEFAULT FALSE, created_at TIMESTAMPTZ DEFAULT NOW(),
  change_hash TEXT, is_curated BOOLEAN DEFAULT FALSE, original_text TEXT,
  original_text_formatted TEXT,
  summary_ok BOOLEAN,
  summary_len_simple INTEGER,
  summary_hash TEXT,
  summary_lease_until TIMESTAMPTZ,
  summary_lease_owner TEXT,
  embedding vector(1536), -- For semantic search
  openstates_bill_id TEXT
);
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_text TEXT;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_date DATE;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS progress JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS calendar JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS history JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS openstates_bill_id TEXT;
CREATE TABLE IF NOT EXISTS public.profiles (id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE);
CREATE TABLE IF NOT EXISTS public.legislators (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, party TEXT,
  district TEXT, is_lnf_ally BOOLEAN DEFAULT FALSE, created_at TIMESTAMPTZ DEFAULT NOW(),
  chamber TEXT, photo_url TEXT, email TEXT, lookup_key TEXT,
  provider TEXT NOT NULL DEFAULT 'openstates',
  provider_person_id TEXT NOT NULL,
  title TEXT,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  vote_id BIGINT,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  option TEXT,
  result TEXT,
  yes_count INT,
  no_count INT,
  other_count INT,
  date DATE,
  motion TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(vote_id, legislator_id)
);

CREATE TABLE IF NOT EXISTS public.vote_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider TEXT NOT NULL DEFAULT 'openstates',
  provider_vote_event_id TEXT NOT NULL,
  openstates_vote_event_id TEXT NOT NULL,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  motion TEXT,
  result TEXT,
  chamber TEXT,
  date TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (provider, provider_vote_event_id),
  CONSTRAINT uq_vote_events_external UNIQUE (openstates_vote_event_id)
);

CREATE TABLE IF NOT EXISTS public.vote_records (
  vote_event_id BIGINT NOT NULL REFERENCES public.vote_events(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  person_openstates_id TEXT NOT NULL,
  choice public.vote_choice NOT NULL,
  provider_option TEXT,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (vote_event_id, legislator_id),
  CONSTRAINT uq_vote_records_event_person UNIQUE (vote_event_id, person_openstates_id)
);

CREATE INDEX IF NOT EXISTS vote_events_bill_id_date_idx ON public.vote_events (bill_id, date);

ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS lookup_key TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS provider TEXT;
ALTER TABLE public.legislators ALTER COLUMN provider SET DEFAULT 'openstates';
ALTER TABLE public.legislators ALTER COLUMN provider SET NOT NULL;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS provider_person_id TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS title TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ;
ALTER TABLE public.legislators ALTER COLUMN updated_at SET DEFAULT NOW();
ALTER TABLE public.legislators ALTER COLUMN updated_at SET NOT NULL;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_name = 'votes' AND column_name = 'vote'
  ) THEN
    ALTER TABLE public.votes RENAME COLUMN vote TO option;
  END IF;
END $$;

ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS vote_id BIGINT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS result TEXT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS yes_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS no_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS other_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS date DATE;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS motion TEXT;

ALTER TABLE public.votes DROP CONSTRAINT IF EXISTS votes_bill_id_legislator_id_key;
ALTER TABLE public.votes ADD CONSTRAINT votes_vote_id_legislator_id_key UNIQUE (vote_id, legislator_id);

UPDATE public.legislators
SET lookup_key =
  regexp_replace(lower(coalesce(name, '')), '[^a-z0-9]', '', 'g') || '::' ||
  CASE
    WHEN lower(coalesce(chamber, '')) IN ('upper', 'senate') THEN 'upper'
    WHEN lower(coalesce(chamber, '')) IN ('lower', 'house', 'assembly') THEN 'lower'
    ELSE regexp_replace(lower(coalesce(chamber, '')), '[^a-z0-9]', '', 'g')
  END || '::' ||
  regexp_replace(lower(coalesce(district, '')), '[^a-z0-9]', '', 'g')
WHERE lookup_key IS NULL OR lookup_key = '';

UPDATE public.legislators
SET provider_person_id = COALESCE(provider_person_id, 'legacy-' || id::TEXT)
WHERE provider_person_id IS NULL;

ALTER TABLE public.legislators ALTER COLUMN provider_person_id SET NOT NULL;

ALTER TABLE public.legislators DROP CONSTRAINT IF EXISTS legislators_provider_provider_person_id_key;
ALTER TABLE public.legislators
  ADD CONSTRAINT legislators_provider_provider_person_id_key UNIQUE (provider, provider_person_id);

-- SECTION 3: USER INTERACTION TABLES
CREATE TABLE IF NOT EXISTS public.reactions (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reaction_type TEXT NOT NULL, created_at TIMESTAMPTZ DEFAULT NOW(), PRIMARY KEY (bill_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.bookmarks (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(), PRIMARY KEY (bill_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.bill_translations (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, title TEXT, description TEXT, summary_simple TEXT,
  summary_medium TEXT, summary_complex TEXT, created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, language_code)
);

-- SECTION 4: NOTIFICATIONS & ANALYTICS TABLES
CREATE TABLE IF NOT EXISTS public.user_push_tokens (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  expo_token TEXT NOT NULL, updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('saved', 'upvoted')), created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, bill_id)
);
CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, ts TIMESTAMPTZ DEFAULT NOW(),
  user_id UUID, type TEXT NOT NULL, bill_id BIGINT
);

-- SECTION 5: INFRASTRUCTURE TABLES
CREATE TABLE IF NOT EXISTS public.job_state (
  key TEXT PRIMARY KEY,
  last_run TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.cron_job_errors (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, job_name TEXT NOT NULL,
  error_message TEXT NOT NULL, occurred_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SECTION 6: INDEXES
CREATE INDEX IF NOT EXISTS idx_bills_change_hash ON public.bills(change_hash);
CREATE INDEX IF NOT EXISTS idx_bills_bill_number ON public.bills(bill_number);
CREATE INDEX IF NOT EXISTS idx_bills_embed ON public.bills USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS bills_summary_ok_idx
  ON public.bills ((summary_ok IS DISTINCT FROM TRUE));
CREATE UNIQUE INDEX IF NOT EXISTS idx_bills_openstates_bill_id
  ON public.bills(openstates_bill_id)
  WHERE openstates_bill_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_bills_openstates
  ON public.bills(openstates_bill_id)
  WHERE openstates_bill_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_cron_job_errors_occurred_at ON public.cron_job_errors (occurred_at);
CREATE INDEX IF NOT EXISTS idx_legislators_lookup_key ON public.legislators(lookup_key);
CREATE INDEX IF NOT EXISTS idx_votes_legislator_date ON public.votes(legislator_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_votes_bill ON public.votes(bill_id);
CREATE INDEX IF NOT EXISTS idx_vote_records_legislator ON public.vote_records(legislator_id);

-- SECTION 7: DATABASE FUNCTIONS (RPCs) & TRIGGERS
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$ BEGIN INSERT INTO public.profiles (id) VALUES (new.id); RETURN new; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

CREATE OR REPLACE FUNCTION public.cleanup_old_cron_job_errors() RETURNS VOID AS $$ BEGIN DELETE FROM public.cron_job_errors WHERE occurred_at < NOW() - INTERVAL '30 days'; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.invoke_edge_function(endpoint TEXT, job_name TEXT DEFAULT 'daily-bill-sync')
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  status_code INT;
  anon_key    TEXT;
  base_url    TEXT;
BEGIN
  -- config: prefer Vault, then app_config; if missing, log and exit
  base_url := COALESCE(
    vault.get_secret('functions_base_url'),
    (SELECT value FROM public.app_config WHERE key = 'functions_base_url' LIMIT 1)
  );

  IF base_url IS NULL THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: missing functions_base_url');
    RETURN;
  END IF;

  IF RIGHT(base_url, 1) <> '/' THEN
    base_url := base_url || '/';
  END IF;

  anon_key := vault.get_secret('supabase_anon_key');
  IF anon_key IS NULL THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: missing supabase_anon_key');
    RETURN;
  END IF;

  SELECT status INTO status_code
  FROM net.http_post(
    url     := base_url || endpoint,
    headers := jsonb_build_object('Content-Type', 'application/json', 'apikey', anon_key)
  );

  IF status_code != 200 THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: ' || endpoint || ' returned status ' || status_code);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: ' || endpoint || ' failed: ' || SQLERRM);
END;
$$;

CREATE OR REPLACE FUNCTION public.invoke_sync_updated_bills() RETURNS VOID AS $$
BEGIN
  PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.upsert_bill_and_translation(bill JSONB, tr JSONB)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF bill IS NULL THEN
    RAISE EXCEPTION 'bill payload is required';
  END IF;

  INSERT INTO public.bills (
    id,
    bill_number,
    title,
    description,
    status,
    status_text,
    status_date,
    state_link,
    change_hash,
    original_text,
    original_text_formatted,
    summary_simple,
    summary_medium,
    summary_complex,
    summary_ok,
    summary_len_simple,
    summary_hash,
    progress,
    calendar,
    history,
    embedding
  )
  SELECT
    (bill->>'id')::BIGINT,
    bill->>'bill_number',
    bill->>'title',
    bill->>'description',
    NULLIF(bill->>'status', ''),
    bill->>'status_text',
    (bill->>'status_date')::DATE,
    bill->>'state_link',
    bill->>'change_hash',
    bill->>'original_text',
    bill->>'original_text_formatted',
    bill->>'summary_simple',
    bill->>'summary_medium',
    bill->>'summary_complex',
    (bill->>'summary_ok')::BOOLEAN,
    (bill->>'summary_len_simple')::INTEGER,
    bill->>'summary_hash',
    bill->'progress',
    bill->'calendar',
    bill->'history',
    CASE WHEN bill ? 'embedding' THEN (bill->>'embedding')::vector ELSE NULL END
  ON CONFLICT (id) DO UPDATE SET
    bill_number = EXCLUDED.bill_number,
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    status = EXCLUDED.status,
    status_text = EXCLUDED.status_text,
    status_date = EXCLUDED.status_date,
    state_link = EXCLUDED.state_link,
    change_hash = EXCLUDED.change_hash,
    original_text = EXCLUDED.original_text,
    original_text_formatted = EXCLUDED.original_text_formatted,
    summary_simple = EXCLUDED.summary_simple,
    summary_medium = EXCLUDED.summary_medium,
    summary_complex = EXCLUDED.summary_complex,
    summary_ok = EXCLUDED.summary_ok,
    summary_len_simple = EXCLUDED.summary_len_simple,
    summary_hash = EXCLUDED.summary_hash,
    progress = EXCLUDED.progress,
    calendar = EXCLUDED.calendar,
    history = EXCLUDED.history,
    embedding = CASE
      WHEN EXCLUDED.summary_hash IS DISTINCT FROM public.bills.summary_hash THEN EXCLUDED.embedding
      ELSE public.bills.embedding
    END;

  IF tr IS NOT NULL THEN
    INSERT INTO public.bill_translations (
      bill_id,
      language_code,
      summary_simple,
      summary_medium,
      summary_complex,
      updated_at
    )
    VALUES (
      (tr->>'bill_id')::BIGINT,
      tr->>'language_code',
      tr->>'summary_simple',
      tr->>'summary_medium',
      tr->>'summary_complex',
      COALESCE((tr->>'updated_at')::TIMESTAMPTZ, NOW())
    )
    ON CONFLICT (bill_id, language_code) DO UPDATE SET
      summary_simple = EXCLUDED.summary_simple,
      summary_medium = EXCLUDED.summary_medium,
      summary_complex = EXCLUDED.summary_complex,
      updated_at = EXCLUDED.updated_at;
  END IF;
END;
$$;

REVOKE ALL ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) TO service_role;

CREATE OR REPLACE FUNCTION public.validate_bill_summary(summary_text TEXT, field_name TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE trimmed TEXT;
BEGIN
  IF summary_text IS NULL THEN
    RETURN;
  END IF;
  trimmed := trim(summary_text);
  IF length(trimmed) < 40 OR trimmed ~* '^(error[:\s]|placeholder)' OR trimmed ~* 'placeholder' THEN
    RAISE EXCEPTION 'invalid %', field_name;
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.guard_bill_summaries()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- sanitize placeholder first
  IF NEW.summary_simple IS NOT NULL AND NEW.summary_simple ~* '^Placeholder for[[:space:]]' THEN
    NEW.summary_simple := NULL;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF OLD.summary_simple  IS NOT NULL AND NEW.summary_simple  IS DISTINCT FROM OLD.summary_simple  THEN RAISE EXCEPTION 'summary_simple overwrite blocked';  END IF;
    IF OLD.summary_medium  IS NOT NULL AND NEW.summary_medium  IS DISTINCT FROM OLD.summary_medium  THEN RAISE EXCEPTION 'summary_medium overwrite blocked';  END IF;
    IF OLD.summary_complex IS NOT NULL AND NEW.summary_complex IS DISTINCT FROM OLD.summary_complex THEN RAISE EXCEPTION 'summary_complex overwrite blocked'; END IF;

    IF OLD.summary_simple  IS NULL AND NEW.summary_simple  IS NOT NULL THEN PERFORM public.validate_bill_summary(NEW.summary_simple,  'summary_simple');  END IF;
    IF OLD.summary_medium  IS NULL AND NEW.summary_medium  IS NOT NULL THEN PERFORM public.validate_bill_summary(NEW.summary_medium,  'summary_medium');  END IF;
    IF OLD.summary_complex IS NULL AND NEW.summary_complex IS NOT NULL THEN PERFORM public.validate_bill_summary(NEW.summary_complex, 'summary_complex'); END IF;
  ELSE
    PERFORM public.validate_bill_summary(NEW.summary_simple,  'summary_simple');
    PERFORM public.validate_bill_summary(NEW.summary_medium,  'summary_medium');
    PERFORM public.validate_bill_summary(NEW.summary_complex, 'summary_complex');
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_strip_placeholder_simple ON public.bills;
DROP TRIGGER IF EXISTS trg_guard_bill_summaries ON public.bills;
CREATE TRIGGER trg_guard_bill_summaries
BEFORE INSERT OR UPDATE ON public.bills
FOR EACH ROW EXECUTE FUNCTION public.guard_bill_summaries();

-- defense-in-depth constraint (lazy backfill)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conrelid = 'public.bills'::regclass
      AND conname = 'bills_summary_simple_no_placeholder'
  ) THEN
    EXECUTE
      'ALTER TABLE public.bills
         ADD CONSTRAINT bills_summary_simple_no_placeholder
         CHECK (summary_simple IS NULL OR summary_simple !~* ''^Placeholder for[[:space:]]'')
         NOT VALID';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.lease_next_bill(p_owner text, p_ttl_seconds int DEFAULT 900)
RETURNS BIGINT
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  WITH cte AS (
    SELECT id FROM public.bills
    WHERE (summary_ok IS DISTINCT FROM TRUE)
      AND (summary_lease_until IS NULL OR summary_lease_until < now())
    ORDER BY id
    FOR UPDATE SKIP LOCKED
    LIMIT 1
  )
  UPDATE public.bills b
     SET summary_lease_until = now() + make_interval(secs => p_ttl_seconds),
         summary_lease_owner = p_owner
  FROM cte
  WHERE b.id = cte.id
  RETURNING b.id;
$$;

REVOKE ALL ON FUNCTION public.lease_next_bill(text, int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.lease_next_bill(text, int) TO service_role;

CREATE OR REPLACE FUNCTION public.release_bill_lease(p_id bigint, p_owner text, p_ok boolean)
RETURNS void
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE public.bills
     SET summary_ok = p_ok,
         summary_lease_until = NULL,
         summary_lease_owner = NULL
   WHERE id = p_id
     AND summary_lease_owner = p_owner;
$$;

REVOKE ALL ON FUNCTION public.release_bill_lease(bigint, text, boolean) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.release_bill_lease(bigint, text, boolean) TO service_role;

CREATE OR REPLACE VIEW public.v_bill_summary_leases AS
SELECT id, summary_ok, summary_lease_owner, summary_lease_until
FROM public.bills
WHERE summary_ok IS DISTINCT FROM TRUE
   OR summary_lease_until IS NOT NULL;

CREATE OR REPLACE FUNCTION public.invoke_full_legislative_refresh() RETURNS VOID AS $$
DECLARE
  i INT;
BEGIN
  PERFORM public.invoke_edge_function('bulk-import-dataset', 'daily-bill-sync');
  FOR i IN 1..5 LOOP
    PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
  END LOOP;
  PERFORM public.invoke_edge_function('votes-backfill', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_bill_details_for_user(p_bill_id BIGINT, p_user_id UUID) RETURNS JSONB AS $$ DECLARE bill_details JSONB; reaction_counts JSONB; user_reaction_type TEXT; is_bookmarked BOOLEAN; BEGIN SELECT to_jsonb(b) INTO bill_details FROM public.bills b WHERE b.id = p_bill_id; SELECT jsonb_object_agg(reaction_type, count) INTO reaction_counts FROM (SELECT reaction_type, COUNT(*) AS count FROM public.reactions WHERE bill_id = p_bill_id GROUP BY reaction_type) AS counts; SELECT reaction_type INTO user_reaction_type FROM public.reactions WHERE bill_id = p_bill_id AND user_id = p_user_id; SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE bill_id = p_bill_id AND user_id = p_user_id) INTO is_bookmarked; RETURN jsonb_build_object('bill', bill_details, 'reaction_counts', COALESCE(reaction_counts, '{}'::jsonb), 'user_reaction', user_reaction_type, 'is_bookmarked', is_bookmarked); END; $$ LANGUAGE plpgsql STABLE;
CREATE OR REPLACE FUNCTION public.handle_reaction(p_bill_id BIGINT, p_user_id UUID, p_reaction_type TEXT) RETURNS void AS $$ DECLARE existing_reaction TEXT; BEGIN SELECT reaction_type INTO existing_reaction FROM public.reactions WHERE user_id = p_user_id AND bill_id = p_bill_id; IF FOUND THEN IF existing_reaction = p_reaction_type THEN DELETE FROM public.reactions WHERE user_id = p_user_id AND bill_id = p_bill_id; ELSE UPDATE public.reactions SET reaction_type = p_reaction_type, created_at = NOW() WHERE user_id = p_user_id AND bill_id = p_bill_id; END IF; ELSE INSERT INTO public.reactions (user_id, bill_id, reaction_type) VALUES (p_user_id, p_bill_id, p_reaction_type); END IF; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION public.toggle_bookmark_and_subscription(p_bill_id BIGINT, p_user_id UUID) RETURNS void AS $$ DECLARE bookmark_exists BOOLEAN; BEGIN SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id) INTO bookmark_exists; IF bookmark_exists THEN DELETE FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id; DELETE FROM public.subscriptions WHERE user_id = p_user_id AND bill_id = p_bill_id; ELSE INSERT INTO public.bookmarks (user_id, bill_id) VALUES (p_user_id, p_bill_id); INSERT INTO public.subscriptions (user_id, bill_id, type) VALUES (p_user_id, p_bill_id, 'saved') ON CONFLICT (user_id, bill_id) DO NOTHING; END IF; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION public.get_related_bills(p_bill_id BIGINT) RETURNS TABLE (id BIGINT, bill_number TEXT, title TEXT, similarity FLOAT) LANGUAGE plpgsql AS $$ BEGIN RETURN QUERY WITH source_bill AS (SELECT embedding FROM public.bills WHERE bills.id = p_bill_id) SELECT b.id, b.bill_number, b.title, (1 - (b.embedding <=> (SELECT embedding FROM source_bill)))::FLOAT AS similarity FROM public.bills b, source_bill WHERE b.id <> p_bill_id AND b.embedding IS NOT NULL ORDER BY b.embedding <=> (SELECT embedding FROM source_bill) LIMIT 5; END; $$;

-- SECTION 7A: VIEWS
CREATE OR REPLACE VIEW public.v_rep_vote_history AS
WITH access AS (
  SELECT
    CASE
      WHEN auth.role() = 'service_role' THEN TRUE
      WHEN auth.uid() IS NOT NULL THEN TRUE
      ELSE FALSE
    END AS allowed
)
SELECT
  l.id AS legislator_id,
  l.name AS legislator_name,
  l.party,
  l.district,
  l.title,
  b.id AS bill_id,
  b.bill_number,
  b.title AS bill_title,
  ve.id AS vote_event_id,
  ve.date AS vote_date,
  ve.motion,
  ve.result AS vote_result,
  vr.choice AS vote_choice
FROM public.vote_records vr
JOIN public.vote_events ve ON ve.id = vr.vote_event_id
JOIN public.bills b ON b.id = ve.bill_id
JOIN public.legislators l ON l.id = vr.legislator_id
CROSS JOIN access
WHERE access.allowed;

-- SECTION 8: ROW-LEVEL SECURITY (RLS) POLICIES
ALTER TABLE public.bills ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view bills" ON public.bills; CREATE POLICY "Public can view bills" ON public.bills FOR SELECT USING (true);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view profiles" ON public.profiles; CREATE POLICY "Public can view profiles" ON public.profiles FOR SELECT USING (true);
ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view reactions" ON public.reactions; CREATE POLICY "Public can view reactions" ON public.reactions FOR SELECT USING (true); DROP POLICY IF EXISTS "Users can manage their own reactions" ON public.reactions; CREATE POLICY "Users can manage their own reactions" ON public.reactions FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own bookmarks" ON public.bookmarks; CREATE POLICY "Users can manage their own bookmarks" ON public.bookmarks FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.legislators ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view legislators" ON public.legislators; CREATE POLICY "Public can view legislators" ON public.legislators FOR SELECT USING (true);
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view votes" ON public.votes; CREATE POLICY "Public can view votes" ON public.votes FOR SELECT USING (true);
ALTER TABLE public.vote_events ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view vote events" ON public.vote_events; CREATE POLICY "Public can view vote events" ON public.vote_events FOR SELECT USING (true); DROP POLICY IF EXISTS "Service role manages vote events" ON public.vote_events; CREATE POLICY "Service role manages vote events" ON public.vote_events FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
ALTER TABLE public.vote_records ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view vote records" ON public.vote_records; CREATE POLICY "Public can view vote records" ON public.vote_records FOR SELECT USING (true); DROP POLICY IF EXISTS "Service role manages vote records" ON public.vote_records; CREATE POLICY "Service role manages vote records" ON public.vote_records FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
ALTER TABLE public.job_state ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "job_state_service_role" ON public.job_state; CREATE POLICY job_state_service_role ON public.job_state FOR ALL USING (auth.role() = 'service_role') WITH CHECK (auth.role() = 'service_role');
ALTER TABLE public.bill_translations ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view translations" ON public.bill_translations; CREATE POLICY "Public can view translations" ON public.bill_translations FOR SELECT USING (true); DROP POLICY IF EXISTS "Service role can manage translations" ON public.bill_translations; CREATE POLICY "Service role can manage translations" ON public.bill_translations FOR ALL USING (auth.role() = 'service_role');
ALTER TABLE public.user_push_tokens ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own push token" ON public.user_push_tokens; CREATE POLICY "Users can manage their own push token" ON public.user_push_tokens FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own subscriptions" ON public.subscriptions; CREATE POLICY "Users can manage their own subscriptions" ON public.subscriptions FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Allow service role to insert events" ON public.events; CREATE POLICY "Allow service role to insert events" ON public.events FOR INSERT WITH CHECK (auth.role() = 'service_role');
ALTER TABLE public.cron_job_errors ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Admins can view errors" ON public.cron_job_errors; CREATE POLICY "Admins can view errors" ON public.cron_job_errors FOR SELECT USING (auth.role() = 'service_role');

REVOKE ALL ON public.job_state FROM PUBLIC;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.job_state TO service_role;
REVOKE ALL ON public.v_rep_vote_history FROM PUBLIC;
GRANT SELECT ON public.v_rep_vote_history TO authenticated;
GRANT SELECT ON public.v_rep_vote_history TO service_role;

-- SECTION 9: CRON JOBS
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync') THEN
    PERFORM cron.unschedule('daily-bill-sync');
  END IF;
END;
$$;

SELECT cron.schedule('daily-bill-sync', '0 10 * * *', 'SELECT public.invoke_full_legislative_refresh()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync');

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors') THEN
    PERFORM cron.unschedule('cleanup-cron-job-errors');
  END IF;
END;
$$;

SELECT cron.schedule('cleanup-cron-job-errors', '0 0 * * 0', 'SELECT public.cleanup_old_cron_job_errors()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors');

-- SECTION 10: COMMENTS
COMMENT ON TABLE public.bills IS 'Stores core legislative bill information and AI-generated content.';
COMMENT ON COLUMN public.bills.embedding IS 'Stores vector embeddings for semantic search.';
COMMENT ON TABLE public.bill_translations IS 'Caches AI-generated translations of bill content for various languages.';
COMMENT ON TABLE public.user_push_tokens IS 'Stores Expo push notification tokens for each user.';
COMMENT ON TABLE public.subscriptions IS 'Tracks user subscriptions to bills for targeted notifications.';
COMMENT ON TABLE public.events IS 'Stores anonymous analytics events for understanding app usage.';
COMMENT ON FUNCTION public.get_related_bills(BIGINT) IS 'Returns top 5 semantically similar bills using vector embeddings.';
COMMENT ON FUNCTION public.toggle_bookmark_and_subscription(BIGINT, UUID) IS 'Atomically handles bookmarking/unbookmarking and subscribing/unsubscribing.';
