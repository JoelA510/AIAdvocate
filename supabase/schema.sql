-- =================================================================
-- AI ADVOCATE: V1 STABLE SCHEMA (MERGED & COMPLETE - V2)
-- This script is idempotent and contains the complete schema for the
-- V1 stable build, including all tables, functions, and extensions for
-- all features implemented.
-- =================================================================

-- SECTION 1: EXTENSIONS
CREATE EXTENSION IF NOT EXISTS supabase_vault;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS vector; -- For semantic search

-- SECTION 2: CORE TABLES
CREATE TABLE IF NOT EXISTS public.bills (
  id BIGINT PRIMARY KEY, bill_number TEXT NOT NULL, title TEXT NOT NULL, description TEXT,
  status TEXT, state_link TEXT, summary_simple TEXT, summary_medium TEXT, summary_complex TEXT,
  panel_review JSONB, is_verified BOOLEAN DEFAULT FALSE, created_at TIMESTAMPTZ DEFAULT NOW(),
  change_hash TEXT, is_curated BOOLEAN DEFAULT FALSE, original_text TEXT,
  embedding vector(1536) -- For semantic search
);
CREATE TABLE IF NOT EXISTS public.profiles (id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE);
CREATE TABLE IF NOT EXISTS public.legislators (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, party TEXT,
  district TEXT, is_lnf_ally BOOLEAN DEFAULT FALSE, created_at TIMESTAMPTZ DEFAULT NOW(),
  chamber TEXT, photo_url TEXT, email TEXT, lookup_key TEXT
);
CREATE TABLE IF NOT EXISTS public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  vote_id BIGINT,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  option TEXT,
  result TEXT,
  yes_count INT,
  no_count INT,
  other_count INT,
  date DATE,
  motion TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(vote_id, legislator_id)
);

ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS lookup_key TEXT;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_name = 'votes' AND column_name = 'vote'
  ) THEN
    ALTER TABLE public.votes RENAME COLUMN vote TO option;
  END IF;
END $$;

ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS vote_id BIGINT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS result TEXT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS yes_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS no_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS other_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS date DATE;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS motion TEXT;

ALTER TABLE public.votes DROP CONSTRAINT IF EXISTS votes_bill_id_legislator_id_key;
ALTER TABLE public.votes ADD CONSTRAINT votes_vote_id_legislator_id_key UNIQUE (vote_id, legislator_id);

UPDATE public.legislators
SET lookup_key =
  regexp_replace(lower(coalesce(name, '')), '[^a-z0-9]', '', 'g') || '::' ||
  CASE
    WHEN lower(coalesce(chamber, '')) IN ('upper', 'senate') THEN 'upper'
    WHEN lower(coalesce(chamber, '')) IN ('lower', 'house', 'assembly') THEN 'lower'
    ELSE regexp_replace(lower(coalesce(chamber, '')), '[^a-z0-9]', '', 'g')
  END || '::' ||
  regexp_replace(lower(coalesce(district, '')), '[^a-z0-9]', '', 'g')
WHERE lookup_key IS NULL OR lookup_key = '';

-- SECTION 3: USER INTERACTION TABLES
CREATE TABLE IF NOT EXISTS public.reactions (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reaction_type TEXT NOT NULL, created_at TIMESTAMPTZ DEFAULT NOW(), PRIMARY KEY (bill_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.bookmarks (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(), PRIMARY KEY (bill_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.bill_translations (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, title TEXT, description TEXT, summary_simple TEXT,
  summary_medium TEXT, summary_complex TEXT, created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, language_code)
);

-- SECTION 4: NOTIFICATIONS & ANALYTICS TABLES
CREATE TABLE IF NOT EXISTS public.user_push_tokens (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  expo_token TEXT NOT NULL, updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS public.subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('saved', 'upvoted')), created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, bill_id)
);
CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, ts TIMESTAMPTZ DEFAULT NOW(),
  user_id UUID, type TEXT NOT NULL, bill_id BIGINT
);

-- SECTION 5: INFRASTRUCTURE TABLES
CREATE TABLE IF NOT EXISTS public.cron_job_errors (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, job_name TEXT NOT NULL,
  error_message TEXT NOT NULL, occurred_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SECTION 6: INDEXES
CREATE INDEX IF NOT EXISTS idx_bills_change_hash ON public.bills(change_hash);
CREATE INDEX IF NOT EXISTS idx_bills_bill_number ON public.bills(bill_number);
CREATE INDEX IF NOT EXISTS idx_bills_embed ON public.bills USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS idx_cron_job_errors_occurred_at ON public.cron_job_errors (occurred_at);
CREATE INDEX IF NOT EXISTS idx_legislators_lookup_key ON public.legislators(lookup_key);
CREATE INDEX IF NOT EXISTS idx_votes_legislator_date ON public.votes(legislator_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_votes_bill ON public.votes(bill_id);

-- SECTION 7: DATABASE FUNCTIONS (RPCs) & TRIGGERS
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$ BEGIN INSERT INTO public.profiles (id) VALUES (new.id); RETURN new; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

CREATE OR REPLACE FUNCTION public.cleanup_old_cron_job_errors() RETURNS VOID AS $$ BEGIN DELETE FROM public.cron_job_errors WHERE occurred_at < NOW() - INTERVAL '30 days'; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION public.invoke_sync_updated_bills() RETURNS VOID AS $$ DECLARE status_code INT; anon_key TEXT; BEGIN anon_key := vault.get_secret('supabase_anon_key'); SELECT status INTO status_code FROM net.http_post( url:='https://klpwiiszmzzfvlbfsjrd.supabase.co/functions/v1/sync-updated-bills', headers:='{"Content-Type": "application/json", "apikey": "' || anon_key || '"}'); IF status_code != 200 THEN INSERT INTO public.cron_job_errors (job_name, error_message) VALUES ('daily-bill-sync', 'Invoke Error: Edge Function returned status ' || status_code); END IF; END; $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_bill_details_for_user(p_bill_id BIGINT, p_user_id UUID) RETURNS JSONB AS $$ DECLARE bill_details JSONB; reaction_counts JSONB; user_reaction_type TEXT; is_bookmarked BOOLEAN; BEGIN SELECT to_jsonb(b) INTO bill_details FROM public.bills b WHERE b.id = p_bill_id; SELECT jsonb_object_agg(reaction_type, count) INTO reaction_counts FROM (SELECT reaction_type, COUNT(*) AS count FROM public.reactions WHERE bill_id = p_bill_id GROUP BY reaction_type) AS counts; SELECT reaction_type INTO user_reaction_type FROM public.reactions WHERE bill_id = p_bill_id AND user_id = p_user_id; SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE bill_id = p_bill_id AND user_id = p_user_id) INTO is_bookmarked; RETURN jsonb_build_object('bill', bill_details, 'reaction_counts', COALESCE(reaction_counts, '{}'::jsonb), 'user_reaction', user_reaction_type, 'is_bookmarked', is_bookmarked); END; $$ LANGUAGE plpgsql STABLE;
CREATE OR REPLACE FUNCTION public.handle_reaction(p_bill_id BIGINT, p_user_id UUID, p_reaction_type TEXT) RETURNS void AS $$ DECLARE existing_reaction TEXT; BEGIN SELECT reaction_type INTO existing_reaction FROM public.reactions WHERE user_id = p_user_id AND bill_id = p_bill_id; IF FOUND THEN IF existing_reaction = p_reaction_type THEN DELETE FROM public.reactions WHERE user_id = p_user_id AND bill_id = p_bill_id; ELSE UPDATE public.reactions SET reaction_type = p_reaction_type, created_at = NOW() WHERE user_id = p_user_id AND bill_id = p_bill_id; END IF; ELSE INSERT INTO public.reactions (user_id, bill_id, reaction_type) VALUES (p_user_id, p_bill_id, p_reaction_type); END IF; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION public.toggle_bookmark_and_subscription(p_bill_id BIGINT, p_user_id UUID) RETURNS void AS $$ DECLARE bookmark_exists BOOLEAN; BEGIN SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id) INTO bookmark_exists; IF bookmark_exists THEN DELETE FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id; DELETE FROM public.subscriptions WHERE user_id = p_user_id AND bill_id = p_bill_id; ELSE INSERT INTO public.bookmarks (user_id, bill_id) VALUES (p_user_id, p_bill_id); INSERT INTO public.subscriptions (user_id, bill_id, type) VALUES (p_user_id, p_bill_id, 'saved') ON CONFLICT (user_id, bill_id) DO NOTHING; END IF; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION public.get_related_bills(p_bill_id BIGINT) RETURNS TABLE (id BIGINT, bill_number TEXT, title TEXT, similarity FLOAT) LANGUAGE plpgsql AS $$ BEGIN RETURN QUERY WITH source_bill AS (SELECT embedding FROM public.bills WHERE bills.id = p_bill_id) SELECT b.id, b.bill_number, b.title, (1 - (b.embedding <=> (SELECT embedding FROM source_bill)))::FLOAT AS similarity FROM public.bills b, source_bill WHERE b.id <> p_bill_id AND b.embedding IS NOT NULL ORDER BY b.embedding <=> (SELECT embedding FROM source_bill) LIMIT 5; END; $$;

-- SECTION 8: ROW-LEVEL SECURITY (RLS) POLICIES
ALTER TABLE public.bills ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view bills" ON public.bills; CREATE POLICY "Public can view bills" ON public.bills FOR SELECT USING (true);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view profiles" ON public.profiles; CREATE POLICY "Public can view profiles" ON public.profiles FOR SELECT USING (true);
ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view reactions" ON public.reactions; CREATE POLICY "Public can view reactions" ON public.reactions FOR SELECT USING (true); DROP POLICY IF EXISTS "Users can manage their own reactions" ON public.reactions; CREATE POLICY "Users can manage their own reactions" ON public.reactions FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own bookmarks" ON public.bookmarks; CREATE POLICY "Users can manage their own bookmarks" ON public.bookmarks FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.legislators ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view legislators" ON public.legislators; CREATE POLICY "Public can view legislators" ON public.legislators FOR SELECT USING (true);
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view votes" ON public.votes; CREATE POLICY "Public can view votes" ON public.votes FOR SELECT USING (true);
ALTER TABLE public.bill_translations ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Public can view translations" ON public.bill_translations; CREATE POLICY "Public can view translations" ON public.bill_translations FOR SELECT USING (true); DROP POLICY IF EXISTS "Service role can manage translations" ON public.bill_translations; CREATE POLICY "Service role can manage translations" ON public.bill_translations FOR ALL USING (auth.role() = 'service_role');
ALTER TABLE public.user_push_tokens ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own push token" ON public.user_push_tokens; CREATE POLICY "Users can manage their own push token" ON public.user_push_tokens FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can manage their own subscriptions" ON public.subscriptions; CREATE POLICY "Users can manage their own subscriptions" ON public.subscriptions FOR ALL USING (auth.uid() = user_id);
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Allow service role to insert events" ON public.events; CREATE POLICY "Allow service role to insert events" ON public.events FOR INSERT WITH CHECK (auth.role() = 'service_role');
ALTER TABLE public.cron_job_errors ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Admins can view errors" ON public.cron_job_errors; CREATE POLICY "Admins can view errors" ON public.cron_job_errors FOR SELECT USING (auth.role() = 'service_role');

-- SECTION 9: CRON JOBS
SELECT cron.schedule('daily-bill-sync', '0 10 * * *', 'SELECT public.invoke_sync_updated_bills()');
SELECT cron.schedule('cleanup-cron-job-errors', '0 0 * * 0', 'SELECT public.cleanup_old_cron_job_errors()');

-- SECTION 10: COMMENTS
COMMENT ON TABLE public.bills IS 'Stores core legislative bill information and AI-generated content.';
COMMENT ON COLUMN public.bills.embedding IS 'Stores vector embeddings for semantic search.';
COMMENT ON TABLE public.bill_translations IS 'Caches AI-generated translations of bill content for various languages.';
COMMENT ON TABLE public.user_push_tokens IS 'Stores Expo push notification tokens for each user.';
COMMENT ON TABLE public.subscriptions IS 'Tracks user subscriptions to bills for targeted notifications.';
COMMENT ON TABLE public.events IS 'Stores anonymous analytics events for understanding app usage.';
COMMENT ON FUNCTION public.get_related_bills(BIGINT) IS 'Returns top 5 semantically similar bills using vector embeddings.';
COMMENT ON FUNCTION public.toggle_bookmark_and_subscription(BIGINT, UUID) IS 'Atomically handles bookmarking/unbookmarking and subscribing/unsubscribing.';
