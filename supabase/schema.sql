-- ================================================================
-- AI ADVOCATE: V1.6.1 CONSOLIDATED SCHEMA & POLICIES (IDEMPOTENT)
-- Vector search, ranked FTS, translations cache, RLS, realtime guard
-- ================================================================

-- ---------- EXTENSIONS ----------
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS supabase_vault;

GRANT USAGE ON SCHEMA public TO anon, authenticated;

-- ---------- TYPES ----------
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vote_choice') THEN
    CREATE TYPE public.vote_choice AS ENUM (
      'yay',
      'nay',
      'abstain',
      'absent',
      'excused',
      'other'
    );
  END IF;
END;
$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ai_job_status') THEN
    CREATE TYPE public.ai_job_status AS ENUM ('ok', 'empty', 'http_error', 'exception', 'invoke_error');
  END IF;
END;
$$;

-- ---------- CORE TABLES ----------
CREATE TABLE IF NOT EXISTS public.bills (
  id BIGINT PRIMARY KEY,
  bill_number TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  change_hash TEXT,
  is_curated BOOLEAN DEFAULT FALSE,
  original_text TEXT,
  original_text_formatted TEXT,
  summary_ok BOOLEAN,
  summary_len_simple INTEGER,
  summary_hash TEXT,
  summary_lease_until TIMESTAMPTZ,
  summary_lease_owner TEXT,
  embedding vector(1536) -- semantic search
);
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_text TEXT;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS status_date DATE;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS progress JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS calendar JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS history JSONB;
ALTER TABLE public.bills ADD COLUMN IF NOT EXISTS openstates_bill_id TEXT;

CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.legislators (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  party TEXT,
  district TEXT,
  chamber TEXT,
  photo_url TEXT,
  email TEXT,
  is_lnf_ally BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  lookup_key TEXT,
  provider TEXT NOT NULL DEFAULT 'openstates',
  provider_person_id TEXT NOT NULL,
  title TEXT,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  vote_id BIGINT,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  option TEXT,
  result TEXT,
  yes_count INT,
  no_count INT,
  other_count INT,
  date DATE,
  motion TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (vote_id, legislator_id)
);

CREATE TABLE IF NOT EXISTS public.vote_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider TEXT NOT NULL DEFAULT 'openstates',
  provider_vote_event_id TEXT NOT NULL,
  openstates_vote_event_id TEXT NOT NULL,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  motion TEXT,
  result TEXT,
  chamber TEXT,
  date TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (provider, provider_vote_event_id),
  CONSTRAINT uq_vote_events_external UNIQUE (openstates_vote_event_id)
);

CREATE TABLE IF NOT EXISTS public.vote_records (
  vote_event_id BIGINT NOT NULL REFERENCES public.vote_events(id) ON DELETE CASCADE,
  legislator_id BIGINT NOT NULL REFERENCES public.legislators(id) ON DELETE CASCADE,
  person_openstates_id TEXT NOT NULL,
  choice public.vote_choice NOT NULL,
  provider_option TEXT,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (vote_event_id, legislator_id),
  CONSTRAINT uq_vote_records_event_person UNIQUE (vote_event_id, person_openstates_id)
);

ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS lookup_key TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS provider TEXT;
ALTER TABLE public.legislators ALTER COLUMN provider SET DEFAULT 'openstates';
ALTER TABLE public.legislators ALTER COLUMN provider SET NOT NULL;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS provider_person_id TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS title TEXT;
ALTER TABLE public.legislators ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ;
ALTER TABLE public.legislators ALTER COLUMN updated_at SET DEFAULT NOW();
ALTER TABLE public.legislators ALTER COLUMN updated_at SET NOT NULL;

UPDATE public.legislators
SET provider_person_id = COALESCE(provider_person_id, 'legacy-' || id::TEXT)
WHERE provider_person_id IS NULL;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'legislators_provider_provider_person_id_key'
  ) THEN
    ALTER TABLE public.legislators
      ADD CONSTRAINT legislators_provider_provider_person_id_key UNIQUE (provider, provider_person_id);
  END IF;
END $$;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_name = 'votes' AND column_name = 'vote'
  ) THEN
    ALTER TABLE public.votes RENAME COLUMN vote TO option;
  END IF;
END $$;

ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS vote_id BIGINT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS result TEXT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS yes_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS no_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS other_count INT;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS date DATE;
ALTER TABLE public.votes ADD COLUMN IF NOT EXISTS motion TEXT;

-- User interaction
CREATE TABLE IF NOT EXISTS public.reactions (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reaction_type TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.bookmarks (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.app_admins (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Translations cache
CREATE TABLE IF NOT EXISTS public.bill_translations (
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, -- ISO 639-1 (e.g., 'es')
  title TEXT,
  description TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  original_text TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (bill_id, language_code)
);

CREATE TABLE IF NOT EXISTS public.location_lookup_cache (
  lookup_key TEXT PRIMARY KEY,
  raw_query TEXT NOT NULL,
  query_type TEXT NOT NULL CHECK (query_type IN ('zip', 'city')),
  lat DOUBLE PRECISION NOT NULL,
  lon DOUBLE PRECISION NOT NULL,
  representatives JSONB NOT NULL,
  hit_count INTEGER NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_hit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '7 days')
);

-- Notifications & analytics
CREATE TABLE IF NOT EXISTS public.user_push_tokens (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  expo_token TEXT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  bill_id BIGINT NOT NULL REFERENCES public.bills(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('saved', 'upvoted')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, bill_id)
);

CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts TIMESTAMPTZ DEFAULT NOW(),
  user_id UUID,
  type TEXT NOT NULL,
  bill_id BIGINT
);

-- Infra
CREATE TABLE IF NOT EXISTS public.job_state (
  key TEXT PRIMARY KEY,
  last_run TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.cron_job_errors (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  job_name TEXT NOT NULL,
  error_message TEXT NOT NULL,
  occurred_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.ai_job_log (
  id BIGSERIAL PRIMARY KEY,
  ts TIMESTAMPTZ DEFAULT NOW(),
  job TEXT NOT NULL,
  bill_id BIGINT,
  status public.ai_job_status NOT NULL,
  http_status INT,
  finish_reason TEXT,
  model TEXT,
  response_id TEXT,
  token_usage JSONB,
  prompt_chars INT,
  content_chars INT,
  preview TEXT,
  error TEXT
);

CREATE OR REPLACE FUNCTION public.invoke_edge_function(endpoint TEXT, job_name TEXT DEFAULT 'daily-bill-sync')
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  status_code INT;
  anon_key    TEXT;
  base_url    TEXT;
BEGIN
  -- prefer Vault, then app_config
  base_url := COALESCE(
    vault.get_secret('functions_base_url'),
    (SELECT value FROM public.app_config WHERE key = 'functions_base_url' LIMIT 1)
  );

  IF base_url IS NULL OR base_url = '' THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: missing functions_base_url (Vault and app_config empty)');
    RETURN;
  END IF;

  anon_key := vault.get_secret('supabase_anon_key');
  IF anon_key IS NULL OR anon_key = '' THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: missing supabase_anon_key');
    RETURN;
  END IF;

  -- normalize final URL
  base_url := rtrim(base_url, '/');

  SELECT status INTO status_code
  FROM net.http_post(
    url     := base_url || '/' || endpoint,
    headers := jsonb_build_object('Content-Type','application/json','apikey', anon_key)::text
  );

  IF status_code <> 200 THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: ' || endpoint || ' returned status ' || status_code);
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO public.cron_job_errors(job_name, error_message)
    VALUES (job_name, 'Invoke Error: ' || endpoint || ' failed: ' || SQLERRM);
END;
$$;

REVOKE ALL ON FUNCTION public.invoke_edge_function(text, text) FROM PUBLIC;
GRANT  EXECUTE ON FUNCTION public.invoke_edge_function(text, text) TO service_role;

CREATE OR REPLACE FUNCTION public.invoke_sync_updated_bills() RETURNS VOID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
BEGIN
  PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
END;
$$;

CREATE OR REPLACE FUNCTION public.upsert_bill_and_translation(bill JSONB, tr JSONB)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF bill IS NULL THEN
    RAISE EXCEPTION 'bill payload is required';
  END IF;

  INSERT INTO public.bills (
    id,
    bill_number,
    title,
    description,
    status,
    status_text,
    status_date,
    state_link,
    change_hash,
    original_text,
    original_text_formatted,
    summary_simple,
    summary_medium,
    summary_complex,
    summary_ok,
    summary_len_simple,
    summary_hash,
    progress,
    calendar,
    history,
    embedding
  )
  SELECT
    (bill->>'id')::BIGINT,
    bill->>'bill_number',
    bill->>'title',
    bill->>'description',
    NULLIF(bill->>'status', ''),
    bill->>'status_text',
    (bill->>'status_date')::DATE,
    bill->>'state_link',
    bill->>'change_hash',
    bill->>'original_text',
    bill->>'original_text_formatted',
    bill->>'summary_simple',
    bill->>'summary_medium',
    bill->>'summary_complex',
    (bill->>'summary_ok')::BOOLEAN,
    (bill->>'summary_len_simple')::INTEGER,
    bill->>'summary_hash',
    bill->'progress',
    bill->'calendar',
    bill->'history',
    CASE WHEN bill ? 'embedding' THEN (bill->>'embedding')::vector ELSE NULL END
  ON CONFLICT (id) DO UPDATE SET
    bill_number = EXCLUDED.bill_number,
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    status = EXCLUDED.status,
    status_text = EXCLUDED.status_text,
    status_date = EXCLUDED.status_date,
    state_link = EXCLUDED.state_link,
    change_hash = EXCLUDED.change_hash,
    original_text = EXCLUDED.original_text,
    original_text_formatted = EXCLUDED.original_text_formatted,
    summary_simple = EXCLUDED.summary_simple,
    summary_medium = EXCLUDED.summary_medium,
    summary_complex = EXCLUDED.summary_complex,
    summary_ok = EXCLUDED.summary_ok,
    summary_len_simple = EXCLUDED.summary_len_simple,
    summary_hash = EXCLUDED.summary_hash,
    progress = EXCLUDED.progress,
    calendar = EXCLUDED.calendar,
    history = EXCLUDED.history,
    embedding = CASE
      WHEN EXCLUDED.summary_hash IS DISTINCT FROM public.bills.summary_hash THEN EXCLUDED.embedding
      ELSE public.bills.embedding
    END;

  IF tr IS NOT NULL THEN
    INSERT INTO public.bill_translations (
      bill_id,
      language_code,
      summary_simple,
      summary_medium,
      summary_complex,
      updated_at
    )
    VALUES (
      (tr->>'bill_id')::BIGINT,
      tr->>'language_code',
      tr->>'summary_simple',
      tr->>'summary_medium',
      tr->>'summary_complex',
      COALESCE((tr->>'updated_at')::TIMESTAMPTZ, NOW())
    )
    ON CONFLICT (bill_id, language_code) DO UPDATE SET
      summary_simple = EXCLUDED.summary_simple,
      summary_medium = EXCLUDED.summary_medium,
      summary_complex = EXCLUDED.summary_complex,
      updated_at = EXCLUDED.updated_at;
  END IF;
END;
$$;

REVOKE ALL ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.upsert_bill_and_translation(jsonb, jsonb) TO service_role;

-- Helper to validate one summary field
CREATE OR REPLACE FUNCTION public.validate_bill_summary(summary_text TEXT, field_name TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
  trimmed TEXT;
BEGIN
  IF summary_text IS NULL THEN
    RETURN;
  END IF;

  trimmed := trim(summary_text);
  IF length(trimmed) < 40 OR trimmed ~* '^(error[:\s]|placeholder)' OR trimmed ~* 'placeholder' THEN
    RAISE EXCEPTION 'invalid %', field_name;
  END IF;
END;
$$;

-- Single BEFORE trigger
CREATE OR REPLACE FUNCTION public.guard_bill_summaries()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- sanitize placeholder
  IF NEW.summary_simple IS NOT NULL AND NEW.summary_simple ~* '^Placeholder for[[:space:]]' THEN
    NEW.summary_simple := NULL;
  END IF;

  -- block overwrites
  IF TG_OP = 'UPDATE' THEN
    IF OLD.summary_simple IS NOT NULL AND NEW.summary_simple IS DISTINCT FROM OLD.summary_simple THEN
      RAISE EXCEPTION 'summary_simple overwrite blocked';
    END IF;
    IF OLD.summary_medium IS NOT NULL AND NEW.summary_medium IS DISTINCT FROM OLD.summary_medium THEN
      RAISE EXCEPTION 'summary_medium overwrite blocked';
    END IF;
    IF OLD.summary_complex IS NOT NULL AND NEW.summary_complex IS DISTINCT FROM OLD.summary_complex THEN
      RAISE EXCEPTION 'summary_complex overwrite blocked';
    END IF;
  END IF;

  -- validate newly-set fields
  IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.summary_simple IS NULL)) THEN
    PERFORM public.validate_bill_summary(NEW.summary_simple, 'summary_simple');
  END IF;
  IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.summary_medium IS NULL)) THEN
    PERFORM public.validate_bill_summary(NEW.summary_medium, 'summary_medium');
  END IF;
  IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.summary_complex IS NULL)) THEN
    PERFORM public.validate_bill_summary(NEW.summary_complex, 'summary_complex');
  END IF;

  RETURN NEW;
END;
$$;

-- Trigger reset
DROP TRIGGER IF EXISTS trg_strip_placeholder_simple ON public.bills;
DROP TRIGGER IF EXISTS trg_guard_bill_summaries ON public.bills;
CREATE TRIGGER trg_guard_bill_summaries
BEFORE INSERT OR UPDATE ON public.bills
FOR EACH ROW EXECUTE FUNCTION public.guard_bill_summaries();

-- defense-in-depth constraint (lazy backfill)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conrelid = 'public.bills'::regclass
      AND conname = 'bills_summary_simple_no_placeholder'
  ) THEN
    ALTER TABLE public.bills
      ADD CONSTRAINT bills_summary_simple_no_placeholder
      CHECK (summary_simple IS NULL OR summary_simple !~* '^Placeholder for[[:space:]]')
      NOT VALID;
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.lease_next_bill(p_owner text, p_ttl_seconds int DEFAULT 900)
RETURNS BIGINT
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  WITH cte AS (
    SELECT id FROM public.bills
    WHERE (summary_ok IS DISTINCT FROM TRUE)
      AND (summary_lease_until IS NULL OR summary_lease_until < now())
    ORDER BY id
    FOR UPDATE SKIP LOCKED
    LIMIT 1
  )
  UPDATE public.bills b
     SET summary_lease_until = now() + make_interval(secs => p_ttl_seconds),
         summary_lease_owner = p_owner
  FROM cte
  WHERE b.id = cte.id
  RETURNING b.id;
$$;

REVOKE ALL ON FUNCTION public.lease_next_bill(text, int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.lease_next_bill(text, int) TO service_role;

CREATE OR REPLACE FUNCTION public.release_bill_lease(p_id bigint, p_owner text, p_ok boolean)
RETURNS void
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE public.bills
     SET summary_ok = p_ok,
         summary_lease_until = NULL,
         summary_lease_owner = NULL
   WHERE id = p_id
     AND summary_lease_owner = p_owner;
$$;

REVOKE ALL ON FUNCTION public.release_bill_lease(bigint, text, boolean) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.release_bill_lease(bigint, text, boolean) TO service_role;

CREATE OR REPLACE VIEW public.v_bill_summary_leases AS
SELECT id, summary_ok, summary_lease_owner, summary_lease_until
FROM public.bills
WHERE summary_ok IS DISTINCT FROM TRUE
   OR summary_lease_until IS NOT NULL;

CREATE OR REPLACE FUNCTION public.invoke_full_legislative_refresh() RETURNS VOID AS $$
DECLARE
  i INT;
BEGIN
  PERFORM public.invoke_edge_function('bulk-import-dataset', 'daily-bill-sync');
  FOR i IN 1..5 LOOP
    PERFORM public.invoke_edge_function('sync-updated-bills', 'daily-bill-sync');
  END LOOP;
  PERFORM public.invoke_edge_function('votes-backfill', 'daily-bill-sync');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- App config (public values read by clients)
CREATE TABLE IF NOT EXISTS public.app_config (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO public.app_config (key, value)
VALUES ('functions_base_url', 'https://klpwiiszmzzfvlbfsjrd.supabase.co/functions/v1')
ON CONFLICT (key) DO NOTHING;

-- ---------- INDEXES ----------
CREATE INDEX IF NOT EXISTS idx_bills_change_hash ON public.bills(change_hash);
CREATE INDEX IF NOT EXISTS idx_bills_bill_number ON public.bills(bill_number);
CREATE INDEX IF NOT EXISTS idx_bills_embed ON public.bills
  USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS bills_summary_ok_idx
  ON public.bills ((summary_ok IS DISTINCT FROM TRUE));
CREATE INDEX IF NOT EXISTS idx_cron_job_errors_occurred_at ON public.cron_job_errors(occurred_at);
CREATE INDEX IF NOT EXISTS location_lookup_cache_expires_idx ON public.location_lookup_cache (expires_at);
CREATE UNIQUE INDEX IF NOT EXISTS idx_bills_openstates_bill_id
  ON public.bills(openstates_bill_id)
  WHERE openstates_bill_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_bills_openstates
  ON public.bills(openstates_bill_id)
  WHERE openstates_bill_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS vote_events_bill_id_date_idx ON public.vote_events (bill_id, date);
CREATE INDEX IF NOT EXISTS idx_vote_records_legislator ON public.vote_records(legislator_id);
CREATE INDEX IF NOT EXISTS ai_job_log_bill_job_ts ON public.ai_job_log (bill_id, job, ts DESC);

-- ---------- FULL-TEXT SEARCH (ranked) ----------
ALTER TABLE public.bills
  ADD COLUMN IF NOT EXISTS search tsvector
  GENERATED ALWAYS AS (
    setweight(to_tsvector('english', coalesce(bill_number, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(description, '')), 'B') ||
    setweight(to_tsvector('english', coalesce(summary_simple, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_medium, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(summary_complex, '')), 'C') ||
    setweight(to_tsvector('english', coalesce(original_text, '')), 'D')
  ) STORED;

CREATE INDEX IF NOT EXISTS bills_search_gin ON public.bills USING GIN (search);

-- ---------- RLS ----------
ALTER TABLE public.bills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.legislators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vote_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vote_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bill_translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.location_lookup_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_push_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cron_job_errors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.app_admins FROM anon;
REVOKE ALL ON TABLE public.app_admins FROM authenticated;

-- Public readable tables
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bills' AND policyname='read bills public') THEN
    CREATE POLICY "read bills public" ON public.bills FOR SELECT TO anon, authenticated USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='legislators' AND policyname='read legislators public') THEN
    CREATE POLICY "read legislators public" ON public.legislators FOR SELECT TO anon, authenticated USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='votes' AND policyname='Public can view votes') THEN
    CREATE POLICY "Public can view votes" ON public.votes FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='vote_events' AND policyname='read vote_events public') THEN
    CREATE POLICY "read vote_events public" ON public.vote_events FOR SELECT TO anon, authenticated USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='vote_records' AND policyname='read vote_records public') THEN
    CREATE POLICY "read vote_records public" ON public.vote_records FOR SELECT TO anon, authenticated USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Public can view translations') THEN
    CREATE POLICY "Public can view translations" ON public.bill_translations FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='location_lookup_cache' AND policyname='Public can read location cache') THEN
    CREATE POLICY "Public can read location cache" ON public.location_lookup_cache FOR SELECT USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='app_admins' AND policyname='Admins can read own record') THEN
    CREATE POLICY "Admins can read own record" ON public.app_admins
      FOR SELECT TO authenticated USING (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='app_config' AND policyname='Allow authenticated users to read config') THEN
    CREATE POLICY "Allow authenticated users to read config" ON public.app_config FOR SELECT TO authenticated USING (true);
  END IF;
END $$;

GRANT SELECT ON TABLE public.app_admins TO authenticated;

-- User-owned tables (USING + WITH CHECK)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='reactions' AND policyname='Users can manage their own reactions') THEN
    CREATE POLICY "Users can manage their own reactions" ON public.reactions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bookmarks' AND policyname='Users can manage their own bookmarks') THEN
    CREATE POLICY "Users can manage their own bookmarks" ON public.bookmarks
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='subscriptions' AND policyname='Users can manage their own subscriptions') THEN
    CREATE POLICY "Users can manage their own subscriptions" ON public.subscriptions
      FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Service role write policies (WITH CHECK for RLS writes)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='bill_translations' AND policyname='Service role can manage translations') THEN
    DROP POLICY "Service role can manage translations" ON public.bill_translations;
  END IF;
  CREATE POLICY "Service role can manage translations" ON public.bill_translations
    FOR ALL TO service_role USING (true) WITH CHECK (true);

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='vote_events' AND policyname='Service role manages vote events') THEN
    CREATE POLICY "Service role manages vote events" ON public.vote_events
      FOR ALL TO service_role USING (true) WITH CHECK (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='vote_records' AND policyname='Service role manages vote records') THEN
    CREATE POLICY "Service role manages vote records" ON public.vote_records
      FOR ALL TO service_role USING (true) WITH CHECK (true);
  END IF;

  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='job_state' AND policyname='job_state_service_role') THEN
    DROP POLICY job_state_service_role ON public.job_state;
  END IF;

  CREATE POLICY job_state_service_role
    ON public.job_state
    FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);
END $$;

REVOKE ALL ON public.job_state FROM PUBLIC;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.job_state TO service_role;
REVOKE ALL ON public.v_rep_vote_history FROM PUBLIC;
GRANT SELECT ON public.v_rep_vote_history TO anon, authenticated;

-- ---------- RPCs ----------
-- Toggle Bookmark + Subscription
CREATE OR REPLACE FUNCTION public.toggle_bookmark_and_subscription(p_bill_id BIGINT, p_user_id UUID)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE bookmark_exists BOOLEAN;
BEGIN
  SELECT EXISTS (SELECT 1 FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id)
  INTO bookmark_exists;

  IF bookmark_exists THEN
    DELETE FROM public.bookmarks WHERE user_id = p_user_id AND bill_id = p_bill_id;
    DELETE FROM public.subscriptions WHERE user_id = p_user_id AND bill_id = p_bill_id;
  ELSE
    INSERT INTO public.bookmarks (user_id, bill_id) VALUES (p_user_id, p_bill_id);
    INSERT INTO public.subscriptions (user_id, bill_id, type)
      VALUES (p_user_id, p_bill_id, 'saved')
      ON CONFLICT (user_id, bill_id) DO NOTHING;
  END IF;
END;
$$;

COMMENT ON FUNCTION public.toggle_bookmark_and_subscription(BIGINT, UUID)
IS 'Atomically toggles a user bookmark and matching subscription.';

-- Related bills via embeddings
CREATE OR REPLACE FUNCTION public.get_related_bills(p_bill_id BIGINT)
RETURNS TABLE (id BIGINT, bill_number TEXT, title TEXT, similarity FLOAT)
LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  WITH source_bill AS (SELECT embedding FROM public.bills WHERE bills.id = p_bill_id)
  SELECT
    b.id, b.bill_number, b.title,
    (1 - (b.embedding <=> (SELECT embedding FROM source_bill)))::FLOAT AS similarity
  FROM public.bills b, source_bill
  WHERE b.id <> p_bill_id AND b.embedding IS NOT NULL
  ORDER BY b.embedding <=> (SELECT embedding FROM source_bill)
  LIMIT 5;
END;
$$;

COMMENT ON FUNCTION public.get_related_bills(BIGINT)
IS 'Returns top 5 semantically similar bills using vector embeddings.';

CREATE OR REPLACE VIEW public.v_rep_vote_history
WITH (security_invoker = true) AS
SELECT
  l.id AS legislator_id,
  l.name AS legislator_name,
  l.party,
  l.district,
  l.title,
  b.id AS bill_id,
  b.bill_number,
  b.title AS bill_title,
  ve.id AS vote_event_id,
  ve.date AS vote_date,
  ve.motion,
  ve.result AS vote_result,
  vr.choice AS vote_choice
FROM public.vote_records vr
JOIN public.vote_events ve ON ve.id = vr.vote_event_id
JOIN public.bills b        ON b.id = ve.bill_id
JOIN public.legislators l  ON l.id = vr.legislator_id;

CREATE OR REPLACE FUNCTION public.search_bills(p_query TEXT)
RETURNS TABLE (
  id BIGINT,
  bill_number TEXT,
  title TEXT,
  description TEXT,
  status TEXT,
  state_link TEXT,
  summary_simple TEXT,
  summary_medium TEXT,
  summary_complex TEXT,
  panel_review JSONB,
  is_verified BOOLEAN,
  created_at TIMESTAMPTZ,
  change_hash TEXT,
  is_curated BOOLEAN,
  original_text TEXT,
  embedding vector(1536),
  status_text TEXT,
  status_date DATE,
  progress JSONB,
  calendar JSONB,
  history JSONB,
  rank DOUBLE PRECISION
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
  trimmed TEXT := trim(p_query);
  condensed TEXT := regexp_replace(trimmed, '\s+', '', 'g');
  tsq TSQUERY;
  result_rows INTEGER;
BEGIN
  IF trimmed IS NULL OR trimmed = '' THEN
    RETURN;
  END IF;

  IF length(condensed) < 3 THEN
    RETURN QUERY
    SELECT
      b.id,
      b.bill_number,
      b.title,
      b.description,
      b.status,
      b.state_link,
      b.summary_simple,
      b.summary_medium,
      b.summary_complex,
      b.panel_review,
      b.is_verified,
      b.created_at,
      b.change_hash,
      b.is_curated,
      b.original_text,
      b.embedding,
      b.status_text,
      b.status_date,
      b.progress,
      b.calendar,
      b.history,
      0::DOUBLE PRECISION AS rank
    FROM public.bills b
    WHERE
      b.bill_number ILIKE concat(condensed, '%')
      OR b.bill_number ILIKE concat('%', condensed, '%')
      OR b.title ILIKE concat('%', trimmed, '%')
    ORDER BY
      b.is_curated DESC,
      COALESCE(b.status_date, b.created_at) DESC,
      b.created_at DESC,
      b.id DESC;
    RETURN;
  END IF;

  tsq := websearch_to_tsquery('english', trimmed);

  IF tsq IS NOT NULL AND tsq::text <> '' THEN
    RETURN QUERY
    WITH docs AS (
      SELECT
        b.*,
        setweight(to_tsvector('english', coalesce(b.bill_number, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(b.title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(b.description, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(b.summary_simple, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(b.summary_medium, '')), 'C') ||
        setweight(to_tsvector('english', coalesce(b.summary_complex, '')), 'C') ||
        setweight(to_tsvector('english', coalesce(b.original_text, '')), 'D') AS document
      FROM public.bills b
    )
    SELECT
      d.id,
      d.bill_number,
      d.title,
      d.description,
      d.status,
      d.state_link,
      d.summary_simple,
      d.summary_medium,
      d.summary_complex,
      d.panel_review,
      d.is_verified,
      d.created_at,
      d.change_hash,
      d.is_curated,
      d.original_text,
      d.embedding,
      d.status_text,
      d.status_date,
      d.progress,
      d.calendar,
      d.history,
      ts_rank_cd(d.document, tsq)::DOUBLE PRECISION AS rank
    FROM docs d
    WHERE d.document @@ tsq
    ORDER BY rank DESC, d.is_curated DESC, d.created_at DESC;

    GET DIAGNOSTICS result_rows = ROW_COUNT;
    IF result_rows > 0 THEN
      RETURN;
    END IF;
  END IF;

  RETURN QUERY
  SELECT
    b.id,
    b.bill_number,
    b.title,
    b.description,
    b.status,
    b.state_link,
    b.summary_simple,
    b.summary_medium,
    b.summary_complex,
    b.panel_review,
    b.is_verified,
    b.created_at,
    b.change_hash,
    b.is_curated,
    b.original_text,
    b.embedding,
    b.status_text,
    b.status_date,
    b.progress,
    b.calendar,
    b.history,
    0::DOUBLE PRECISION AS rank
  FROM public.bills b
  WHERE
    b.bill_number ILIKE concat('%', trimmed, '%')
    OR b.title ILIKE concat('%', trimmed, '%')
    OR b.description ILIKE concat('%', trimmed, '%')
  ORDER BY
    b.is_curated DESC,
    COALESCE(b.status_date, b.created_at) DESC,
    b.created_at DESC,
    b.id DESC;
END;
$$;

COMMENT ON FUNCTION public.search_bills(TEXT)
IS 'Ranked websearch over bills.search tsvector with graceful fallback for short or sparse queries.';

-- Simple profile bootstrap on new auth user
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id) VALUES (NEW.id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Cron helpers
CREATE OR REPLACE FUNCTION public.cleanup_old_cron_job_errors() RETURNS VOID AS $$
BEGIN
  DELETE FROM public.cron_job_errors WHERE occurred_at < NOW() - INTERVAL '30 days';
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.cleanup_expired_location_cache() RETURNS VOID AS $$
BEGIN
  DELETE FROM public.location_lookup_cache WHERE expires_at <= NOW();
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync') THEN
    PERFORM cron.unschedule('daily-bill-sync');
  END IF;
END;
$$;

SELECT cron.schedule('daily-bill-sync', '0 10 * * *', 'SELECT public.invoke_full_legislative_refresh()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'daily-bill-sync');

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors') THEN
    PERFORM cron.unschedule('cleanup-cron-job-errors');
  END IF;
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-location-cache') THEN
    PERFORM cron.unschedule('cleanup-location-cache');
  END IF;
END;
$$;

SELECT cron.schedule('cleanup-cron-job-errors', '0 0 * * 0', 'SELECT public.cleanup_old_cron_job_errors()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-cron-job-errors');

SELECT cron.schedule('cleanup-location-cache', '0 3 * * *', 'SELECT public.cleanup_expired_location_cache()')
WHERE NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'cleanup-location-cache');

DO $$
DECLARE
  original_timezone TEXT := current_setting('TimeZone');
BEGIN
  BEGIN
    PERFORM cron.unschedule('votes-daily');
  EXCEPTION
    WHEN others THEN
      NULL;
  END;

  PERFORM set_config('TimeZone', 'America/Los_Angeles', true);

  PERFORM cron.schedule(
    'votes-daily',
    '15 2 * * *',
    'SELECT public.invoke_edge_function(''votes-daily'', ''votes-daily'')'
  );

  PERFORM set_config('TimeZone', original_timezone, true);
END;
$$;

-- ---------- REALTIME (guarded) ----------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime'
      AND schemaname = 'public'
      AND tablename = 'bookmarks'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.bookmarks';
  END IF;
END $$;

-- ---------- COMMENTS ----------
COMMENT ON TABLE public.bills IS 'Core legislative bill info + AI-generated content + embedding + FTS vector.';
COMMENT ON COLUMN public.bills.embedding IS 'Vector embeddings for semantic search.';
COMMENT ON TABLE public.bill_translations IS 'Caches AI-generated translations per bill per language.';
COMMENT ON TABLE public.user_push_tokens IS 'Expo push tokens per user.';
COMMENT ON TABLE public.subscriptions IS 'Bill subscriptions (saved/upvoted) for notifications.';
COMMENT ON TABLE public.events IS 'Anonymous analytics events.';
COMMENT ON TABLE public.app_admins IS 'Whitelist of application admins by user_id (auth.users).';
COMMENT ON TABLE public.location_lookup_cache IS 'Caches non-specific location lookups (ZIP or city) to reduce external API usage.';
COMMENT ON COLUMN public.location_lookup_cache.lookup_key IS 'Normalized cache key in the form "<type>:<value>" (type is zip or city).';
COMMENT ON COLUMN public.location_lookup_cache.representatives IS 'Cached OpenStates representatives array for the location.';
COMMENT ON TABLE public.ai_job_log IS 'Logs AI summarization and translation job executions and outcomes.';
